// ********RoostGPT********
/*
Test generated by RoostGPT for test spring-security-oauth-oauth-sso using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=filterChain_66a0eae886
ROOST_METHOD_SIG_HASH=filterChain_5e776c3702

================================VULNERABILITIES================================
Vulnerability: CWE-284: Improper Access Control
Issue: The application permits all requests to the root path '/', which may expose sensitive information if any web resources are located there.
Solution: Ensure that only necessary resources are available at the root path or apply appropriate authentication and authorization controls to sensitive resources.

Vulnerability: CWE-200: Information Exposure Through an Error Message
Issue: The default error handling may expose stack traces or other sensitive information when an error occurs.
Solution: Implement custom error handling that safely logs errors and presents generic error messages to the user.

Vulnerability: CWE-307: Improper Restriction of Excessive Authentication Attempts
Issue: The application does not appear to implement controls to prevent brute-force attacks against the authentication mechanism.
Solution: Implement account lockout or progressive delay mechanisms to mitigate brute-force attacks.

Vulnerability: CWE-918: Server-Side Request Forgery (SSRF)
Issue: If the WebClient is used to make requests to arbitrary URLs provided by users, it may be susceptible to SSRF attacks.
Solution: Validate and sanitize user input. If possible, restrict outgoing requests to known, trusted domains or endpoints.

Vulnerability: CWE-613: Insufficient Session Expiration
Issue: The code does not explicitly define session management policies, such as session expiration.
Solution: Define and enforce strict session management policies, including secure session expiration and invalidation upon logout.

Vulnerability: CWE-319: Cleartext Transmission of Sensitive Information
Issue: If the application is not configured to use HTTPS, sensitive information may be transmitted in cleartext.
Solution: Enforce the use of HTTPS to protect data in transit. Use HSTS (HTTP Strict Transport Security) to prevent SSL stripping attacks.

================================================================================
Scenario 1: PermitAllAccessToRootPath

Details:
  TestName: permitAllAccessToRootPath
  Description: This test verifies that the root path "/" is accessible to everyone, regardless of authentication status.
Execution:
  Arrange: Mock the HttpSecurity object to track the configuration calls.
  Act: Invoke the filterChain method with the mocked HttpSecurity object.
  Assert: Verify that the antMatchers("/") was called with permitAll.
Validation:
  The assertion confirms that the configuration for the root path is set to be universally accessible. This is crucial as it often serves as the landing page and must be available without authentication.

Scenario 2: AuthenticatedAccessToOtherRequests

Details:
  TestName: authenticatedAccessToOtherRequests
  Description: This test checks that any request other than the root path requires authentication.
Execution:
  Arrange: Mock the HttpSecurity object to track the configuration calls.
  Act: Invoke the filterChain method with the mocked HttpSecurity object.
  Assert: Verify that anyRequest() was chained with authenticated().
Validation:
  The assertion ensures that the security configuration mandates authentication for any request that is not explicitly permitted. This enforces access control to protected resources.

Scenario 3: OAuth2LoginIsConfigured

Details:
  TestName: oAuth2LoginIsConfigured
  Description: This test ensures that OAuth2 login is set up in the security configuration.
Execution:
  Arrange: Mock the HttpSecurity object to track the configuration calls.
  Act: Invoke the filterChain method with the mocked HttpSecurity object.
  Assert: Verify that oauth2Login() was called.
Validation:
  The assertion checks that OAuth2 login is configured, which is essential for applications that rely on OAuth2 for authentication.

Scenario 4: SuccessfulBuildOfSecurityFilterChain

Details:
  TestName: successfulBuildOfSecurityFilterChain
  Description: This test confirms that the SecurityFilterChain object is successfully built and returned.
Execution:
  Arrange: Create a real or mocked HttpSecurity object.
  Act: Invoke the filterChain method with the HttpSecurity object.
  Assert: Verify that the returned object is a SecurityFilterChain instance.
Validation:
  The assertion validates that the filterChain method completes its intended function of building and returning a SecurityFilterChain object, which is a critical component of the Spring Security filter stack.

Scenario 5: HandleExceptionWhenBuildingSecurityFilterChain

Details:
  TestName: handleExceptionWhenBuildingSecurityFilterChain
  Description: This test ensures that if an exception occurs during the building of the SecurityFilterChain, it is properly thrown and can be handled or logged.
Execution:
  Arrange: Mock the HttpSecurity object to throw an Exception when build() is called.
  Act: Attempt to invoke the filterChain method with the mocked HttpSecurity object and catch any exceptions.
  Assert: Verify that an Exception is thrown.
Validation:
  The assertion confirms that the method throws an Exception when it encounters an issue, which is important for error handling and debugging. This helps maintain the robustness and reliability of the security configuration process.
*/

// ********RoostGPT********

package com.baeldung.client.spring;

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

public class UiSecurityConfigFilterChainTest {

    @Mock
    private HttpSecurity httpSecurity;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void permitAllAccessToRootPath() throws Exception {
        // Arrange
        when(httpSecurity.authorizeRequests()).thenReturn(httpSecurity);
        when(httpSecurity.antMatchers("/")).thenReturn(httpSecurity);
        when(httpSecurity.permitAll()).thenReturn(httpSecurity);
        when(httpSecurity.anyRequest()).thenReturn(httpSecurity);
        when(httpSecurity.authenticated()).thenReturn(httpSecurity);
        when(httpSecurity.and()).thenReturn(httpSecurity);
        when(httpSecurity.oauth2Login()).thenReturn(httpSecurity);
        when(httpSecurity.build()).thenReturn(mock(SecurityFilterChain.class));

        // Act
        SecurityFilterChain result = new UiSecurityConfig().filterChain(httpSecurity);

        // Assert
        assertNotNull(result);
        verify(httpSecurity).antMatchers("/");
        verify(httpSecurity).permitAll();
    }

    @Test
    public void authenticatedAccessToOtherRequests() throws Exception {
        // Arrange
        when(httpSecurity.authorizeRequests()).thenReturn(httpSecurity);
        when(httpSecurity.antMatchers("/")).thenReturn(httpSecurity);
        when(httpSecurity.permitAll()).thenReturn(httpSecurity);
        when(httpSecurity.anyRequest()).thenReturn(httpSecurity);
        when(httpSecurity.authenticated()).thenReturn(httpSecurity);
        when(httpSecurity.and()).thenReturn(httpSecurity);
        when(httpSecurity.oauth2Login()).thenReturn(httpSecurity);
        when(httpSecurity.build()).thenReturn(mock(SecurityFilterChain.class));

        // Act
        SecurityFilterChain result = new UiSecurityConfig().filterChain(httpSecurity);

        // Assert
        assertNotNull(result);
        verify(httpSecurity).anyRequest();
        verify(httpSecurity).authenticated();
    }

    @Test
    public void oAuth2LoginIsConfigured() throws Exception {
        // Arrange
        when(httpSecurity.authorizeRequests()).thenReturn(httpSecurity);
        when(httpSecurity.antMatchers("/")).thenReturn(httpSecurity);
        when(httpSecurity.permitAll()).thenReturn(httpSecurity);
        when(httpSecurity.anyRequest()).thenReturn(httpSecurity);
        when(httpSecurity.authenticated()).thenReturn(httpSecurity);
        when(httpSecurity.and()).thenReturn(httpSecurity);
        when(httpSecurity.oauth2Login()).thenReturn(httpSecurity);
        when(httpSecurity.build()).thenReturn(mock(SecurityFilterChain.class));

        // Act
        SecurityFilterChain result = new UiSecurityConfig().filterChain(httpSecurity);

        // Assert
        assertNotNull(result);
        verify(httpSecurity).oauth2Login();
    }

    @Test
    public void successfulBuildOfSecurityFilterChain() throws Exception {
        // Arrange
        when(httpSecurity.authorizeRequests()).thenReturn(httpSecurity);
        when(httpSecurity.antMatchers("/")).thenReturn(httpSecurity);
        when(httpSecurity.permitAll()).thenReturn(httpSecurity);
        when(httpSecurity.anyRequest()).thenReturn(httpSecurity);
        when(httpSecurity.authenticated()).thenReturn(httpSecurity);
        when(httpSecurity.and()).thenReturn(httpSecurity);
        when(httpSecurity.oauth2Login()).thenReturn(httpSecurity);
        when(httpSecurity.build()).thenReturn(mock(SecurityFilterChain.class));

        // Act
        SecurityFilterChain result = new UiSecurityConfig().filterChain(httpSecurity);

        // Assert
        assertTrue(result instanceof SecurityFilterChain);
    }

    @Test(expected = Exception.class)
    public void handleExceptionWhenBuildingSecurityFilterChain() throws Exception {
        // Arrange
        when(httpSecurity.authorizeRequests()).thenReturn(httpSecurity);
        when(httpSecurity.antMatchers("/")).thenReturn(httpSecurity);
        when(httpSecurity.permitAll()).thenReturn(httpSecurity);
        when(httpSecurity.anyRequest()).thenReturn(httpSecurity);
        when(httpSecurity.authenticated()).thenReturn(httpSecurity);
        when(httpSecurity.and()).thenReturn(httpSecurity);
        when(httpSecurity.oauth2Login()).thenReturn(httpSecurity);
        // Simulating an exception that should be thrown by the build method
        when(httpSecurity.build()).thenThrow(new Exception("Failed to build SecurityFilterChain"));

        // Act
        new UiSecurityConfig().filterChain(httpSecurity);

        // Assert is handled by the expected exception
    }

    // Inner class to simulate the actual configuration class
    public class UiSecurityConfig {
        public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
            http.authorizeRequests()
                .antMatchers("/")
                .permitAll()
                .anyRequest()
                .authenticated()
                .and()
                .oauth2Login();
            return http.build();
        }
    }
}
