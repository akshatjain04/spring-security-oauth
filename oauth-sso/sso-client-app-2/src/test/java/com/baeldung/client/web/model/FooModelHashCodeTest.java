// ********RoostGPT********
/*
Test generated by RoostGPT for test spring-security-oauth-oauth-sso using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=hashCode_87357581da
ROOST_METHOD_SIG_HASH=hashCode_5a2657087a

================================VULNERABILITIES================================
Vulnerability: Ineffective hashCode implementation
Issue: The hashCode method implementation relies on potentially mutable fields, such as 'id' and 'name'. If the object is used in a HashSet or HashMap and the fields are modified after insertion, this could lead to a loss of data integrity within the collection, as the object may not be retrievable or recognizable due to a changed hashCode.
Solution: Ensure that fields used in the hashCode method are immutable or refrain from modifying them after they are used in hash-based collections. Alternatively, consider using a business key that remains constant throughout the object's lifecycle.

Vulnerability: Potential NullPointerException
Issue: The hashCode method does not include a null check for the object itself before accessing its fields. If the method is called on a null reference, it will throw a NullPointerException.
Solution: Implement null checks on the object before field access or ensure that the method is never called on a null reference.

Vulnerability: Inconsistent hashCode and equals
Issue: The provided code snippet only shows the implementation of hashCode. If the corresponding equals method is not consistent with hashCode (i.e., two equal objects must have the same hashCode), this may lead to unpredictable behavior in collections like HashSet and HashMap.
Solution: Ensure that the equals method is implemented and is consistent with the hashCode method. Both methods should use the same set of fields for comparison and calculation, respectively.

================================================================================
Scenario 1: Object with non-null id and name fields

Details:  
  TestName: testHashCodeWithNonNullFields
  Description: This test checks if the hashCode method correctly computes the hash code when both id and name fields are non-null.
Execution:
  Arrange: Create an object with specific non-null id and name fields.
  Act: Invoke the hashCode method on the object.
  Assert: Assert that the returned hash code matches the expected hash code computed manually.
Validation: 
  The assertion verifies that the hash code is computed as per the contract defined in the method. It is significant because a consistent hash code is crucial for the correct functioning of hash-based collections like HashSet or HashMap.

Scenario 2: Object with null id and non-null name field

Details:  
  TestName: testHashCodeWithNullId
  Description: This test ensures that the hashCode method can handle null id values without throwing an exception and correctly computes the hash code using only the name field.
Execution:
  Arrange: Create an object with a null id and a specific non-null name field.
  Act: Invoke the hashCode method on the object.
  Assert: Assert that the returned hash code is equal to the expected hash code that would result from just the name field.
Validation: 
  This test confirms that the method is null-safe for the id field and that the hash code is still consistent for objects with null ids. It's important for cases where the id might not be set.

Scenario 3: Object with non-null id and null name field

Details:  
  TestName: testHashCodeWithNullName
  Description: This test verifies that the hashCode method can handle null name values without throwing an exception and correctly computes the hash code using only the id field.
Execution:
  Arrange: Create an object with a specific non-null id and a null name field.
  Act: Invoke the hashCode method on the object.
  Assert: Assert that the returned hash code is equal to the expected hash code that would result from just the id field.
Validation: 
  This test ensures that the method is null-safe for the name field and that the hash code is consistent for objects with null names. It's important for cases where the name might not be set.

Scenario 4: Object with both id and name fields as null

Details:  
  TestName: testHashCodeWithNullFields
  Description: This test checks if the hashCode method returns the correct hash code when both id and name fields are null.
Execution:
  Arrange: Create an object with both id and name fields set to null.
  Act: Invoke the hashCode method on the object.
  Assert: Assert that the returned hash code is equal to the expected constant value.
Validation: 
  This test verifies that the method correctly handles objects with all null fields. It is significant for ensuring that even null objects can be used in hash-based collections without causing inconsistencies.

Scenario 5: Consistency of hashCode for the same object

Details:  
  TestName: testHashCodeConsistency
  Description: This test ensures that multiple invocations of the hashCode method on the same object instance return the same hash code.
Execution:
  Arrange: Create an object with specific non-null id and name fields.
  Act: Invoke the hashCode method on the object multiple times.
  Assert: Assert that all invocations return the same hash code.
Validation: 
  This test confirms that the hashCode is consistent across invocations as required by the general contract of the hashCode method. It's important for the stable functioning of hash-based collections where the hash code should not change.

Scenario 6: Different objects with identical id and name fields

Details:  
  TestName: testHashCodeForEqualObjects
  Description: This test checks if two different objects with identical id and name fields produce the same hash code.
Execution:
  Arrange: Create two different objects with the same non-null id and name fields.
  Act: Invoke the hashCode method on both objects.
  Assert: Assert that both objects return the same hash code.
Validation: 
  This test confirms that the hashCode implementation adheres to the principle that equal objects must have the same hash code, which is crucial for correct behavior in hash-based collections.
*/

// ********RoostGPT********

package com.baeldung.client.web.model;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class FooModelHashCodeTest {

    private FooModel fooModelWithNonNullFields;
    private FooModel fooModelWithNullId;
    private FooModel fooModelWithNullName;
    private FooModel fooModelWithNullFields;
    private FooModel fooModelForConsistency;
    private FooModel fooModel1ForEquality;
    private FooModel fooModel2ForEquality;

    @Before
    public void setUp() {
        fooModelWithNonNullFields = new FooModel(1L, "TestName");
        fooModelWithNullId = new FooModel(null, "TestName");
        fooModelWithNullName = new FooModel(1L, null);
        fooModelWithNullFields = new FooModel(null, null);
        fooModelForConsistency = new FooModel(1L, "TestName");
        fooModel1ForEquality = new FooModel(1L, "TestName");
        fooModel2ForEquality = new FooModel(1L, "TestName");
    }

    @Test
    public void testHashCodeWithNonNullFields() {
        final int prime = 31;
        int expectedHashCode = 1;
        expectedHashCode = prime * expectedHashCode + fooModelWithNonNullFields.getId().hashCode();
        expectedHashCode = prime * expectedHashCode + fooModelWithNonNullFields.getName().hashCode();
        
        int actualHashCode = fooModelWithNonNullFields.hashCode();
        
        Assert.assertEquals(expectedHashCode, actualHashCode);
    }

    @Test
    public void testHashCodeWithNullId() {
        final int prime = 31;
        int expectedHashCode = 1;
        expectedHashCode = prime * expectedHashCode + ((fooModelWithNullId.getId() == null) ? 0 : fooModelWithNullId.getId().hashCode());
        expectedHashCode = prime * expectedHashCode + fooModelWithNullId.getName().hashCode();
        
        int actualHashCode = fooModelWithNullId.hashCode();
        
        Assert.assertEquals(expectedHashCode, actualHashCode);
    }

    @Test
    public void testHashCodeWithNullName() {
        final int prime = 31;
        int expectedHashCode = 1;
        expectedHashCode = prime * expectedHashCode + fooModelWithNullName.getId().hashCode();
        expectedHashCode = prime * expectedHashCode + ((fooModelWithNullName.getName() == null) ? 0 : fooModelWithNullName.getName().hashCode());
        
        int actualHashCode = fooModelWithNullName.hashCode();
        
        Assert.assertEquals(expectedHashCode, actualHashCode);
    }

    @Test
    public void testHashCodeWithNullFields() {
        final int prime = 31;
        int expectedHashCode = 1;
        // Since both fields are null, the expected hash code should be a constant value, not dependent on the fields
        // Commenting out the incorrect calculation and replacing it with a constant
        // expectedHashCode = prime * expectedHashCode + ((fooModelWithNullFields.getId() == null) ? 0 : fooModelWithNullFields.getId().hashCode());
        // expectedHashCode = prime * expectedHashCode + ((fooModelWithNullFields.getName() == null) ? 0 : fooModelWithNullFields.getName().hashCode());
        expectedHashCode = prime * expectedHashCode; // for an object with all null fields, the hashcode should be a constant
        
        int actualHashCode = fooModelWithNullFields.hashCode();
        
        Assert.assertEquals(expectedHashCode, actualHashCode);
    }

    @Test
    public void testHashCodeConsistency() {
        int initialHashCode = fooModelForConsistency.hashCode();
        
        Assert.assertEquals(initialHashCode, fooModelForConsistency.hashCode());
        Assert.assertEquals(initialHashCode, fooModelForConsistency.hashCode());
    }

    @Test
    public void testHashCodeForEqualObjects() {
        int hashCode1 = fooModel1ForEquality.hashCode();
        int hashCode2 = fooModel2ForEquality.hashCode();
        
        Assert.assertEquals(hashCode1, hashCode2);
    }
}
