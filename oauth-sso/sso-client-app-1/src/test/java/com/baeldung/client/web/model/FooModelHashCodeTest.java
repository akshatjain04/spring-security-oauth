// ********RoostGPT********
/*
Test generated by RoostGPT for test spring-security-oauth-oauth-sso using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=hashCode_87357581da
ROOST_METHOD_SIG_HASH=hashCode_5a2657087a

================================VULNERABILITIES================================
Vulnerability: Ineffective null check leading to potential NullPointerException
Issue: If 'id' or 'name' are null, calling hashCode() on them will throw a NullPointerException, which could lead to denial of service if not properly handled.
Solution: Ensure that 'id' and 'name' are checked for null before calling hashCode(), or use Objects.hashCode(obj) which is null-safe.

Vulnerability: Improper hashCode implementation
Issue: The hashCode method should consistently return the same integer if the object does not change. Improper implementation may lead to unexpected behavior in hash-based collections like HashMap or HashSet.
Solution: Verify that all fields involved in the equals method are also used in the hashCode method, and that the calculation is consistent with the equals contract.

Vulnerability: Missing equals method
Issue: The hashCode method is present without a corresponding equals method, which can lead to inconsistency and violate the contract that equal objects must have equal hash codes.
Solution: Implement an equals method that is consistent with the hashCode method. Both methods should use the same set of fields for their computations.

Vulnerability: Information leakage through hashCode
Issue: Depending on the sensitivity of 'id' or 'name', the hashCode may inadvertently leak information if exposed to untrusted parties.
Solution: Consider the sensitivity of the fields used in the hashCode computation and avoid exposing the hash code if it can reveal sensitive information.

================================================================================
Scenario 1: Object with non-null id and name fields

Details:  
  TestName: testHashCodeWithNonNullFields
  Description: This test checks that the hashCode method correctly computes the hash for an object with both id and name fields set to non-null values.
Execution:
  Arrange: Create an object with specific non-null id and name fields.
  Act: Call the hashCode method on the created object.
  Assert: Verify that the returned hash code matches the expected hash code computed manually or by an independent means.
Validation: 
  The assertion verifies that the hash code is consistent with the contract of the hashCode method and that the fields are correctly contributing to the hash calculation. This test is significant because it ensures that objects with the same state produce the same hash code, which is essential for correct behavior in collections like HashSet or HashMap.

Scenario 2: Object with null id and non-null name field

Details:  
  TestName: testHashCodeWithNullId
  Description: This test ensures that the hashCode method can handle a null value for the id field without throwing an exception and still computes a hash code based on the name field.
Execution:
  Arrange: Create an object with a null id field and a non-null name field.
  Act: Call the hashCode method on the created object.
  Assert: Verify that the returned hash code is consistent with the expected hash code that would be computed if the id were not part of the hash.
Validation: 
  This assertion confirms that the hashCode method is null-safe for the id field and that the name field alone can determine the hash code. This is important to prevent NullPointerException and to ensure correct behavior when objects lacking an id are used in hash-based collections.

Scenario 3: Object with non-null id and null name field

Details:  
  TestName: testHashCodeWithNullName
  Description: This test checks that the hashCode method properly computes the hash code when the name field is null, relying solely on the id field's value.
Execution:
  Arrange: Create an object with a non-null id field and a null name field.
  Act: Call the hashCode method on the created object.
  Assert: Verify that the returned hash code is consistent with the expected hash code that would be computed if the name were not part of the hash.
Validation: 
  This assertion ensures that the hashCode method is null-safe for the name field and that the id field alone can determine the hash code. This test is significant for maintaining consistent behavior in hash-based collections when objects have a null name.

Scenario 4: Object with both id and name fields set to null

Details:  
  TestName: testHashCodeWithBothFieldsNull
  Description: This test verifies that the hashCode method returns a consistent hash code when both id and name fields are null.
Execution:
  Arrange: Create an object with both id and name fields set to null.
  Act: Call the hashCode method on the created object.
  Assert: Verify that the returned hash code matches the expected result for an object with no fields contributing to the hash.
Validation: 
  The assertion checks that the hashCode method can handle an object with all null fields, which is important to avoid NullPointerException and to ensure that such objects can be included in hash-based collections without issues.

Scenario 5: Consistency of hashCode for the same object

Details:  
  TestName: testHashCodeConsistencyForSameObject
  Description: This test ensures that multiple invocations of the hashCode method on the same object instance return the same hash code.
Execution:
  Arrange: Create an object with specific non-null id and name fields.
  Act: Call the hashCode method on the object multiple times.
  Assert: Verify that all invocations return the same hash code.
Validation: 
  This assertion confirms the consistency requirement of the hashCode contract, which states that the hash code of an object should remain unchanged as long as the object's state does not change. This is essential for the reliable operation of hash-based collections.

Scenario 6: Distinct hashCode for objects with different states

Details:  
  TestName: testHashCodeDistinctnessForDifferentObjects
  Description: This test checks that two objects with different id or name fields yield different hash codes.
Execution:
  Arrange: Create two objects with different id and/or name fields.
  Act: Call the hashCode method on both objects.
  Assert: Verify that the hash codes are different.
Validation: 
  The assertion checks that the hashCode method provides a reasonable spread of hash values for distinct objects. While hash collisions are possible, this test aims to catch obvious flaws in the hash function that could lead to an excessive number of collisions, which would degrade the performance of hash-based collections.
*/

// ********RoostGPT********
package com.baeldung.client.web.model;

import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.*;

public class FooModelHashCodeTest {
    private FooModel fooWithNonNullFields;
    private FooModel fooWithNullId;
    private FooModel fooWithNullName;
    private FooModel fooWithBothFieldsNull;

    @Before
    public void setUp() {
        fooWithNonNullFields = new FooModel(1L, "Foo");
        fooWithNullId = new FooModel(null, "Foo");
        fooWithNullName = new FooModel(1L, null);
        fooWithBothFieldsNull = new FooModel(null, null);
    }

    @Test
    public void testHashCodeWithNonNullFields() {
        final int prime = 31;
        int expectedResult = 1;
        expectedResult = prime * expectedResult + fooWithNonNullFields.getId().hashCode();
        expectedResult = prime * expectedResult + fooWithNonNullFields.getName().hashCode();

        assertEquals(expectedResult, fooWithNonNullFields.hashCode());
    }

    @Test
    public void testHashCodeWithNullId() {
        final int prime = 31;
        int expectedResult = 1;
        expectedResult = prime * expectedResult + ((null == null) ? 0 : fooWithNullId.getId().hashCode());
        expectedResult = prime * expectedResult + fooWithNullId.getName().hashCode();

        assertEquals(expectedResult, fooWithNullId.hashCode());
    }

    @Test
    public void testHashCodeWithNullName() {
        final int prime = 31;
        int expectedResult = 1;
        expectedResult = prime * expectedResult + fooWithNullName.getId().hashCode();
        expectedResult = prime * expectedResult + ((null == null) ? 0 : fooWithNullName.getName().hashCode());

        assertEquals(expectedResult, fooWithNullName.hashCode());
    }

    @Test
    public void testHashCodeWithBothFieldsNull() {
        final int prime = 31;
        int expectedResult = 1;
        expectedResult = prime * expectedResult + ((null == null) ? 0 : fooWithBothFieldsNull.getId().hashCode());
        expectedResult = prime * expectedResult + ((null == null) ? 0 : fooWithBothFieldsNull.getName().hashCode());

        assertEquals(expectedResult, fooWithBothFieldsNull.hashCode());
    }

    @Test
    public void testHashCodeConsistencyForSameObject() {
        int firstCallHashCode = fooWithNonNullFields.hashCode();
        int secondCallHashCode = fooWithNonNullFields.hashCode();

        assertEquals(firstCallHashCode, secondCallHashCode);
    }

    @Test
    public void testHashCodeDistinctnessForDifferentObjects() {
        FooModel anotherFoo = new FooModel(2L, "Bar");

        assertNotEquals(fooWithNonNullFields.hashCode(), anotherFoo.hashCode());
    }
}
