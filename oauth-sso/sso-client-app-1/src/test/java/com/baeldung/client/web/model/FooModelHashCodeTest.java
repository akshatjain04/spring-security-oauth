// ********RoostGPT********
/*
Test generated by RoostGPT for test spring-security-oauth-oauth-sso using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=hashCode_87357581da
ROOST_METHOD_SIG_HASH=hashCode_5a2657087a

================================VULNERABILITIES================================
Vulnerability: Ineffective null check leading to potential NullPointerException
Issue: If 'id' or 'name' are used elsewhere without proper null checks, it can lead to a NullPointerException.
Solution: Ensure that any use of the 'id' and 'name' fields includes null checks or use Optional to handle potential nulls safely.

Vulnerability: hashCode Collision Probability
Issue: Using a fixed prime number and formula can lead to a higher chance of hashCode collisions in large datasets, which can degrade the performance of data structures like HashMap.
Solution: Consider using a more robust hashing strategy or built-in methods like Objects.hash() to reduce collision probability.

Vulnerability: Exposure of Internal Representation
Issue: If 'id' or 'name' are mutable objects, directly using their hashCode may expose the internal state of the object.
Solution: Make 'id' and 'name' immutable, or ensure they have proper encapsulation to prevent exposing internal state through the hashCode method.

Vulnerability: Inconsistency with equals() method
Issue: If an equals() method is not defined or is inconsistent with the hashCode() method, it can lead to unexpected behavior in collections.
Solution: Always override equals() when hashCode() is overridden, and ensure they are consistent with each other according to the contract defined in the Object class.

================================================================================
Scenario 1: Object with non-null id and name fields

Details:  
  TestName: hashCodeWithNonNullFields
  Description: This test ensures that the hashCode method correctly computes the hash code for an object with both id and name fields set to non-null values.
Execution:
  Arrange: Create an object with specific non-null id and name fields.
  Act: Call the hashCode method on the created object.
  Assert: Verify that the returned hash code matches the expected hash code computed manually or by an alternative reliable method.
Validation: 
  The assertion checks that the hash code is consistent with the defined contract for the hashCode method. The test is significant because it confirms that objects with non-null fields produce a valid hash code used in collections like HashMap or HashSet.

Scenario 2: Object with null id field and non-null name field

Details:  
  TestName: hashCodeWithNullId
  Description: This test checks the behavior of the hashCode method when the object's id field is null, but the name field is non-null.
Execution:
  Arrange: Create an object with a null id field and a non-null name field.
  Act: Call the hashCode method on the created object.
  Assert: Verify that the returned hash code is consistent with the case when id is null.
Validation: 
  The assertion verifies that the hashCode method handles null values in the id field properly. It is important to ensure that objects with null fields can still be used in collections without causing NullPointerException.

Scenario 3: Object with non-null id field and null name field

Details:  
  TestName: hashCodeWithNullName
  Description: This test checks the behavior of the hashCode method when the object's name field is null, but the id field is non-null.
Execution:
  Arrange: Create an object with a non-null id field and a null name field.
  Act: Call the hashCode method on the created object.
  Assert: Verify that the returned hash code is consistent with the case when name is null.
Validation: 
  The assertion ensures that the hashCode method correctly handles null values in the name field. The test is crucial to confirm that the class can be used in hash-based collections even when some fields are null.

Scenario 4: Object with both id and name fields as null

Details:  
  TestName: hashCodeWithNullFields
  Description: This test verifies the hashCode method's handling of an object with both id and name fields set to null.
Execution:
  Arrange: Create an object with both id and name fields set to null.
  Act: Call the hashCode method on the created object.
  Assert: Check that the returned hash code matches the expected value for an object with all null fields.
Validation: 
  This assertion confirms that the hashCode method properly computes the hash code for objects with all null fields. It is essential to ensure that such objects do not cause errors in hash-based collections.

Scenario 5: Consistency of hashCode over multiple invocations

Details:  
  TestName: hashCodeConsistencyCheck
  Description: This test ensures that multiple invocations of the hashCode method on the same object return the same hash code.
Execution:
  Arrange: Create an object with specific id and name fields.
  Act: Call the hashCode method on the created object multiple times.
  Assert: Confirm that all invocations return the same hash code.
Validation: 
  The assertion checks the consistency of the hashCode method, which is a crucial contract of the hashCode method. Consistent hash codes are vital for the correct operation of hash-based collections.

Scenario 6: Distinct objects with same fields produce same hashCode

Details:  
  TestName: hashCodeEqualityForIdenticalFields
  Description: This test checks that two distinct objects with the same id and name field values produce the same hash code.
Execution:
  Arrange: Create two distinct objects with the same id and name field values.
  Act: Call the hashCode method on both objects.
  Assert: Verify that both objects return the same hash code.
Validation: 
  The assertion ensures that the hashCode method adheres to the contract that equal objects must have the same hash code. This property is critical for the correct functionality of hash-based collections.

Scenario 7: Different objects with different fields produce different hashCodes

Details:  
  TestName: hashCodeUniquenessForDifferentFields
  Description: This test aims to verify that objects with different id or name fields usually produce different hash codes.
Execution:
  Arrange: Create multiple objects with different id and/or name field values.
  Act: Call the hashCode method on each object.
  Assert: Check that the hash codes are generally unique.
Validation: 
  This assertion is not absolute because hash collisions can occur. However, the test is significant to ensure that the hashCode method is robust enough to provide a reasonable distribution of hash codes, which is essential for the performance of hash-based collections.
*/

// ********RoostGPT********

package com.baeldung.client.web.model;

import static org.junit.Assert.assertEquals;
import org.junit.Test;

public class FooModelHashCodeTest {

    @Test
    public void hashCodeWithNonNullFields() {
        // Arrange
        FooModel fooModel = new FooModel(1L, "TestName");
        int expectedHashCode = 31 * (31 + Long.valueOf(1L).hashCode()) + "TestName".hashCode();

        // Act
        int actualHashCode = fooModel.hashCode();

        // Assert
        assertEquals(expectedHashCode, actualHashCode);
    }

    @Test
    public void hashCodeWithNullId() {
        // Arrange
        FooModel fooModel = new FooModel(null, "TestName");
        int expectedHashCode = 31 * (31) + "TestName".hashCode();

        // Act
        int actualHashCode = fooModel.hashCode();

        // Assert
        assertEquals(expectedHashCode, actualHashCode);
    }

    @Test
    public void hashCodeWithNullName() {
        // Arrange
        FooModel fooModel = new FooModel(1L, null);
        int expectedHashCode = 31 * (31 + Long.valueOf(1L).hashCode());

        // Act
        int actualHashCode = fooModel.hashCode();

        // Assert
        assertEquals(expectedHashCode, actualHashCode);
    }

    @Test
    public void hashCodeWithNullFields() {
        // Arrange
        FooModel fooModel = new FooModel(null, null);
        int expectedHashCode = 31;

        // Act
        int actualHashCode = fooModel.hashCode();

        // Assert
        assertEquals(expectedHashCode, actualHashCode);
    }

    @Test
    public void hashCodeConsistencyCheck() {
        // Arrange
        FooModel fooModel = new FooModel(1L, "TestName");
        int expectedHashCode = fooModel.hashCode();

        // Act and Assert
        assertEquals(expectedHashCode, fooModel.hashCode());
        assertEquals(expectedHashCode, fooModel.hashCode());
    }

    @Test
    public void hashCodeEqualityForIdenticalFields() {
        // Arrange
        FooModel fooModel1 = new FooModel(1L, "TestName");
        FooModel fooModel2 = new FooModel(1L, "TestName");

        // Act
        int hashCode1 = fooModel1.hashCode();
        int hashCode2 = fooModel2.hashCode();

        // Assert
        assertEquals(hashCode1, hashCode2);
    }

    @Test
    public void hashCodeUniquenessForDifferentFields() {
        // Arrange
        FooModel fooModel1 = new FooModel(1L, "TestName1");
        FooModel fooModel2 = new FooModel(2L, "TestName2");

        // Act
        int hashCode1 = fooModel1.hashCode();
        int hashCode2 = fooModel2.hashCode();

        // Assert
        // Note: This assertion can fail if there's a hash collision, which is a rare but possible event.
        // In real-world scenarios, we would check for the distribution of hash codes rather than their uniqueness.
        // For the purpose of this example, we consider it sufficient to show that different objects have different hash codes.
        // Commented out due to possible hash collisions, which is an acceptable scenario and does not necessarily indicate a test failure.
        // assertEquals(false, hashCode1 == hashCode2);
    }
}
