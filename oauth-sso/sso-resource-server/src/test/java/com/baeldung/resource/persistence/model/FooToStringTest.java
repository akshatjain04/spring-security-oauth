// ********RoostGPT********
/*
Test generated by RoostGPT for test spring-security-oauth-oauth-sso using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=toString_3c925113b3
ROOST_METHOD_SIG_HASH=toString_ceffa8036e

Scenario 1: Valid toString representation with non-null fields

Details:
  TestName: validToStringRepresentation
  Description: This test verifies that the toString method returns the correct string representation of the Foo object when all fields are properly initialized.
Execution:
  Arrange: Create a Foo object and initialize the id and name fields with valid values.
  Act: Call the toString method on the created Foo object.
  Assert: Check if the returned string matches the expected pattern "Foo [id=value, name=value]".
Validation:
  The assertion validates that the toString method correctly concatenates the object's class name and field values. This test is significant because it ensures that the string representation of the Foo object is accurately constructed for logging or display purposes.

Scenario 2: toString representation with null name field

Details:
  TestName: toStringWithNullName
  Description: This test checks the behavior of the toString method when the name field is null.
Execution:
  Arrange: Create a Foo object with a valid id and a null name.
  Act: Invoke the toString method on the Foo object.
  Assert: Confirm that the returned string correctly includes "null" for the name part.
Validation:
  The assertion confirms that the toString method handles null values gracefully without throwing an exception. This is crucial for the robustness of the method, especially when dealing with incomplete or uninitialized objects.

Scenario 3: toString representation with default id value

Details:
  TestName: toStringWithDefaultId
  Description: This test ensures that the toString method provides the correct string when the id field has its default value (0 if not initialized).
Execution:
  Arrange: Create a Foo object without explicitly setting the id and with a valid name.
  Act: Call the toString method on the Foo object.
  Assert: Verify that the returned string includes the default id value (e.g., "Foo [id=0, name=value]").
Validation:
  The assertion checks that the toString method accurately reflects the default values of uninitialized fields. This test is important to confirm that default or uninitialized values are represented as expected in the string output.

Scenario 4: toString representation for newly instantiated object

Details:
  TestName: toStringForNewInstance
  Description: This test examines the toString output for a newly instantiated Foo object with no fields set (id is 0 and name is null).
Execution:
  Arrange: Instantiate a new Foo object without setting any fields.
  Act: Invoke the toString method on the new Foo object.
  Assert: Assert that the output string matches "Foo [id=0, name=null]".
Validation:
  The assertion ensures that the toString method can handle a newly created object with default values without errors. This test is essential to verify that the method behaves as expected even in scenarios where an object has not been fully initialized.

Scenario 5: toString representation with special characters in name

Details:
  TestName: toStringWithSpecialCharactersInName
  Description: This test checks how the toString method handles a name containing special characters.
Execution:
  Arrange: Create a Foo object with a valid id and a name containing special characters (e.g., "Name@#").
  Act: Call the toString method on the Foo object.
  Assert: Confirm that the special characters are included correctly in the returned string.
Validation:
  The assertion checks that the toString method correctly includes special characters in the string representation. This test is significant to ensure that the method can handle names with non-alphanumeric characters without data loss or corruption.
*/

// ********RoostGPT********
package com.baeldung.resource.persistence.model;

import static org.junit.Assert.assertEquals;
import org.junit.Before;
import org.junit.Test;

public class FooToStringTest {

    private Foo fooWithNonNullFields;
    private Foo fooWithNullName;
    private Foo fooWithDefaultId;
    private Foo fooNewInstance;
    private Foo fooWithSpecialCharactersInName;

    @Before
    public void setUp() {
        fooWithNonNullFields = new Foo();
        fooWithNonNullFields.setId(1L);
        fooWithNonNullFields.setName("TestName");

        fooWithNullName = new Foo();
        fooWithNullName.setId(2L);
        fooWithNullName.setName(null);

        fooWithDefaultId = new Foo("TestName");

        fooNewInstance = new Foo();

        fooWithSpecialCharactersInName = new Foo();
        fooWithSpecialCharactersInName.setId(3L);
        fooWithSpecialCharactersInName.setName("Name@#");
    }

    @Test
    public void validToStringRepresentation() {
        String expected = "Foo [id=1, name=TestName]";
        assertEquals(expected, fooWithNonNullFields.toString());
    }

    @Test
    public void toStringWithNullName() {
        String expected = "Foo [id=2, name=null]";
        assertEquals(expected, fooWithNullName.toString());
    }

    @Test
    public void toStringWithDefaultId() {
        String expected = "Foo [id=0, name=TestName]";
        assertEquals(expected, fooWithDefaultId.toString());
    }

    @Test
    public void toStringForNewInstance() {
        String expected = "Foo [id=0, name=null]";
        assertEquals(expected, fooNewInstance.toString());
    }

    @Test
    public void toStringWithSpecialCharactersInName() {
        String expected = "Foo [id=3, name=Name@#]";
        assertEquals(expected, fooWithSpecialCharactersInName.toString());
    }
}
