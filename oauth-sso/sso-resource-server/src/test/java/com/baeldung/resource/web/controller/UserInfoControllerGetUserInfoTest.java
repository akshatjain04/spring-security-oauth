// ********RoostGPT********
/*
Test generated by RoostGPT for test spring-security-oauth-oauth-sso using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=getUserInfo_d51059726e
ROOST_METHOD_SIG_HASH=getUserInfo_b1939473b7

================================VULNERABILITIES================================
Vulnerability: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
Issue: Returning user-controlled data without proper encoding can lead to Cross-site Scripting (XSS) vulnerabilities when rendered in a web page.
Solution: Ensure that any user-controlled data returned by the API is properly encoded or sanitized to prevent XSS attacks.

Vulnerability: CWE-285: Improper Authorization
Issue: The method does not check if the authenticated user has the correct authorization to access the information, potentially leading to privilege escalation or unauthorized access.
Solution: Implement proper authorization checks to ensure the authenticated user has the right to access the requested information.

Vulnerability: CWE-20: Improper Input Validation
Issue: The code does not validate the 'preferred_username' claim from the JWT, which could potentially be manipulated.
Solution: Validate the 'preferred_username' claim to ensure it meets the application's expectations and does not contain malicious data.

Vulnerability: CWE-200: Information Exposure
Issue: Exposing username or other sensitive details in API responses can lead to information leakage.
Solution: Review the necessity of exposing usernames or other sensitive information. If required, ensure it is done securely and only expose the minimum necessary data.

Vulnerability: CWE-918: Server-Side Request Forgery (SSRF)
Issue: If this endpoint is used to create server-to-server requests based on user input, it could be exploited to perform SSRF attacks.
Solution: Avoid using user input to construct server-side requests or implement strict input validation and whitelisting of allowed resources.

================================================================================
Scenario 1: Valid Jwt with preferred_username claim

Details:
  TestName: getUserInfoWithValidJwt
  Description: This test verifies that the method returns a map containing the username extracted from a valid Jwt token's preferred_username claim.
Execution:
  Arrange: Create a mock Jwt object with a preferred_username claim set to a sample username.
  Act: Call getUserInfo with the mocked Jwt object.
  Assert: Assert that the returned map contains a single entry with "user_name" as the key and the sample username as the value.
Validation:
  The assertion checks if the method correctly extracts the preferred_username claim and returns it in the expected format. It validates the method's ability to handle a valid Jwt token and is significant for ensuring user identity is correctly fetched for authenticated users.

Scenario 2: Jwt without preferred_username claim

Details:
  TestName: getUserInfoWithJwtMissingPreferredUsername
  Description: This test checks the behavior of the method when the Jwt token does not contain the preferred_username claim.
Execution:
  Arrange: Create a mock Jwt object without a preferred_username claim.
  Act: Call getUserInfo with the mocked Jwt object.
  Assert: Assert that the returned map contains a single entry with "user_name" as the key and null as the value.
Validation:
  The assertion ensures that the method handles the absence of the preferred_username claim gracefully by returning null as the username. This scenario is critical for ensuring robustness in cases where the Jwt might not conform to expected claims.

Scenario 3: Jwt with preferred_username claim as null

Details:
  TestName: getUserInfoWithJwtPreferredUsernameAsNull
  Description: This test ensures that the method can handle a Jwt token with a preferred_username claim explicitly set to null.
Execution:
  Arrange: Create a mock Jwt object with a preferred_username claim set to null.
  Act: Call getUserInfo with the mocked Jwt object.
  Assert: Assert that the returned map contains a single entry with "user_name" as the key and null as the value.
Validation:
  The assertion verifies that the method correctly interprets a null preferred_username claim and reflects this in the output. This test is important for ensuring that the method does not break when encountering null values in Jwt claims.

Scenario 4: Jwt with empty string as preferred_username claim

Details:
  TestName: getUserInfoWithJwtPreferredUsernameEmpty
  Description: This test checks the method's behavior when the Jwt token contains an empty string for the preferred_username claim.
Execution:
  Arrange: Create a mock Jwt object with a preferred_username claim set to an empty string.
  Act: Call getUserInfo with the mocked Jwt object.
  Assert: Assert that the returned map contains a single entry with "user_name" as the key and an empty string as the value.
Validation:
  This assertion confirms that the method handles empty string claims correctly without throwing an error. It is significant for ensuring that the user identity is represented accurately even when the claim is present but empty.

Scenario 5: Jwt with non-string preferred_username claim

Details:
  TestName: getUserInfoWithJwtPreferredUsernameNonString
  Description: This test checks how the method processes a Jwt token with a non-string preferred_username claim (e.g., an integer or a list).
Execution:
  Arrange: Create a mock Jwt object with a non-string preferred_username claim.
  Act: Call getUserInfo with the mocked Jwt object.
  Assert: Assert that the returned map contains a single entry with "user_name" as the key and the string representation of the non-string claim as the value.
Validation:
  The assertion ensures that the method can handle different data types for the preferred_username claim by converting them to strings. This is important for ensuring that the method is flexible and can handle unexpected claim formats.

Scenario 6: Null Jwt token

Details:
  TestName: getUserInfoWithNullJwt
  Description: This test verifies the method's behavior when a null Jwt token is passed as the argument.
Execution:
  Arrange: Pass a null value for the Jwt token.
  Act: Call getUserInfo with a null Jwt object.
  Assert: Expect an exception to be thrown.
Validation:
  This assertion checks the method's resilience to null Jwt tokens, which may indicate an error in upstream authentication processes. It is crucial for ensuring that the application can handle unexpected null inputs without crashing.

Scenario 7: Jwt with invalid claim type for preferred_username

Details:
  TestName: getUserInfoWithJwtInvalidClaimType
  Description: This test assesses the method's response when the Jwt token contains a preferred_username claim of an invalid type that cannot be converted to a string.
Execution:
  Arrange: Create a mock Jwt object with a preferred_username claim of a type that is not convertible to a string.
  Act: Call getUserInfo with the mocked Jwt object.
  Assert: Expect an exception to be thrown or a specific error handling to occur.
Validation:
  The assertion ensures that the method can either handle or appropriately report an error when encountering a Jwt claim that cannot be processed. This scenario is essential for ensuring that the application can effectively signal issues with token claims to maintain security and integrity.
*/

// ********RoostGPT********
package com.baeldung.resource.web.controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import java.util.Map;
import org.junit.Test;
import org.springframework.security.oauth2.jwt.Jwt;

public class UserInfoControllerGetUserInfoTest {

    @Test
    public void getUserInfoWithValidJwt() {
        // Arrange
        Jwt mockJwt = mock(Jwt.class);
        when(mockJwt.getClaimAsString("preferred_username")).thenReturn("sampleUser");

        UserInfoController controller = new UserInfoController();

        // Act
        Map<String, Object> result = controller.getUserInfo(mockJwt);

        // Assert
        assertNotNull(result);
        assertEquals("sampleUser", result.get("user_name"));
    }

    @Test
    public void getUserInfoWithJwtMissingPreferredUsername() {
        // Arrange
        Jwt mockJwt = mock(Jwt.class);
        when(mockJwt.getClaimAsString("preferred_username")).thenReturn(null);

        UserInfoController controller = new UserInfoController();

        // Act
        Map<String, Object> result = controller.getUserInfo(mockJwt);

        // Assert
        assertNotNull(result);
        assertNull(result.get("user_name"));
    }

    @Test
    public void getUserInfoWithJwtPreferredUsernameAsNull() {
        // Arrange
        Jwt mockJwt = mock(Jwt.class);
        when(mockJwt.getClaimAsString("preferred_username")).thenReturn(null);

        UserInfoController controller = new UserInfoController();

        // Act
        Map<String, Object> result = controller.getUserInfo(mockJwt);

        // Assert
        assertNotNull(result);
        assertNull(result.get("user_name"));
    }

    @Test
    public void getUserInfoWithJwtPreferredUsernameEmpty() {
        // Arrange
        Jwt mockJwt = mock(Jwt.class);
        when(mockJwt.getClaimAsString("preferred_username")).thenReturn("");

        UserInfoController controller = new UserInfoController();

        // Act
        Map<String, Object> result = controller.getUserInfo(mockJwt);

        // Assert
        assertNotNull(result);
        assertEquals("", result.get("user_name"));
    }

    @Test
    public void getUserInfoWithJwtPreferredUsernameNonString() {
        // Arrange
        Jwt mockJwt = mock(Jwt.class);
        when(mockJwt.getClaimAsString("preferred_username")).thenReturn("123");

        UserInfoController controller = new UserInfoController();

        // Act
        Map<String, Object> result = controller.getUserInfo(mockJwt);

        // Assert
        assertNotNull(result);
        assertEquals("123", result.get("user_name"));
    }

    @Test(expected = IllegalArgumentException.class)
    public void getUserInfoWithNullJwt() {
        // Arrange
        UserInfoController controller = new UserInfoController();

        // Act
        controller.getUserInfo(null);

        // Assert handled by expected exception
    }

    @Test(expected = IllegalArgumentException.class)
    public void getUserInfoWithJwtInvalidClaimType() {
        // Arrange
        Jwt mockJwt = mock(Jwt.class);
        when(mockJwt.getClaimAsString("preferred_username")).thenThrow(new IllegalArgumentException("Invalid type"));

        UserInfoController controller = new UserInfoController();

        // Act
        controller.getUserInfo(mockJwt);

        // Assert handled by expected exception
    }
}
